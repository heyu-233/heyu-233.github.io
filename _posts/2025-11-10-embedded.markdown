---
layout:    post
title:     "å¾®å¤„ç†å™¨ï¼Œç¬”è®°æ€»ç»“"
author:    "maomaoWang"
header-style: text
catalog:  true
tags:
    - åµŒå…¥å¼
    - å¾®å¤„ç†å™¨
---

# week1

## 1.**Embedded Systems Overview**

### a.Microprocessor (MPU) vs. Microcontroller (MCU)

#### Microprocessor (MPU)

â€¢ Typically defined as a single processor core (CPU) supports at least instruction fetching, decoding, and executing. 

â€¢ A single MPU may have many CPUs.

â€¢ Normally for general-purpose computing, but needs to be supported with memories and I/Os.

![image-20250604131322808](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604131322808.png)

#### Microcontroller (MCU)

â€¢ Typically has a MPU (typically a single core) with embedded peripherals e.g. memory blocks, Digital I/Os, Analogue I/Os, and other 

basic peripherals

â€¢ Typically used for basic control purposes, such as embedded applications



| ç‰¹ç‚¹           | **å¾®å¤„ç†å™¨ (MPU)**                                           | **å¾®æ§åˆ¶å™¨ (MCU)**                                           |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **æ ¸å¿ƒæ„æˆ**   | **ä¸»è¦æ˜¯ CPU æ ¸å¿ƒ**ã€‚ä¸“æ³¨äºæŒ‡ä»¤çš„å–æŒ‡ã€è¯‘ç å’Œæ‰§è¡Œã€‚          | **åŒ…å«ä¸€ä¸ª MPU (CPU æ ¸å¿ƒ) + é›†æˆå¤–è®¾**ã€‚æ˜¯ä¸€ä¸ªâ€œç³»ç»Ÿçº§èŠ¯ç‰‡â€(SoC)ã€‚ |
| **é›†æˆåº¦**     | **ä½é›†æˆåº¦**ã€‚é€šå¸¸åªæœ‰ CPU æ ¸å¿ƒæœ¬èº«ã€‚                        | **é«˜é›†æˆåº¦**ã€‚åœ¨å•èŠ¯ç‰‡ä¸Šé›†æˆäº† CPUã€å†…å­˜ã€I/O æ¥å£ã€å®šæ—¶å™¨ã€ADC/DAC ç­‰å¸¸ç”¨å¤–è®¾ã€‚ |
| **å·¥ä½œæ–¹å¼**   | **éœ€è¦å¤–éƒ¨æ”¯æŒ**ã€‚å¿…é¡»æ­é…å¤–éƒ¨å­˜å‚¨å™¨ã€I/O æ¥å£èŠ¯ç‰‡ç­‰æ‰èƒ½æ„æˆå®Œæ•´ç³»ç»Ÿã€‚ | **åŸºæœ¬è‡ªåŒ…å«**ã€‚å•é¢—èŠ¯ç‰‡å°±èƒ½æ„æˆä¸€ä¸ªæœ€å°ç³»ç»Ÿï¼Œå¯ç›´æ¥è¿æ¥ä¼ æ„Ÿå™¨ã€æ‰§è¡Œå™¨ç­‰ã€‚ |
| **ä¸»è¦åº”ç”¨**   | **é€šç”¨è®¡ç®—**ã€‚ç”¨äºéœ€è¦è¾ƒå¼ºå¤„ç†èƒ½åŠ›ã€è¿è¡Œå¤æ‚æ“ä½œç³»ç»Ÿï¼ˆå¦‚ Linux, Windowsï¼‰çš„è®¾å¤‡ï¼šä¸ªäººç”µè„‘ã€æœåŠ¡å™¨ã€é«˜ç«¯æ‰‹æœºã€å¹³æ¿ç­‰ã€‚ | **åµŒå…¥å¼æ§åˆ¶**ã€‚ç”¨äºæ‰§è¡Œç‰¹å®šæ§åˆ¶ä»»åŠ¡çš„è®¾å¤‡ï¼šå®¶ç”µã€æ±½è½¦ç”µå­ã€å·¥ä¸šæ§åˆ¶ã€æ™ºèƒ½ä»ªè¡¨ã€ç‰©è”ç½‘èŠ‚ç‚¹ã€ç®€å•å¤–è®¾ç­‰ã€‚ |
| **ç³»ç»Ÿå¤æ‚åº¦** | **é«˜**ã€‚è®¾è®¡è€…éœ€è¦é€‰é…å’Œè¿æ¥å¤šç§å¤–éƒ¨èŠ¯ç‰‡ï¼Œç³»ç»Ÿè®¾è®¡ç›¸å¯¹å¤æ‚ã€‚ | **ä½**ã€‚åˆ©ç”¨ç‰‡ä¸Šèµ„æºå³å¯æ„å»ºç®€å•ç³»ç»Ÿï¼Œè®¾è®¡ç›¸å¯¹ç®€å•å¿«æ·ã€‚     |
| **åŠŸè€—**       | **é€šå¸¸è¾ƒé«˜**ï¼ˆå°¤å…¶æ˜¯é«˜æ€§èƒ½ MPUï¼‰ã€‚                           | **é€šå¸¸è¾ƒä½**ã€‚é’ˆå¯¹ä½åŠŸè€—åº”ç”¨ä¼˜åŒ–ï¼Œé€‚åˆç”µæ± ä¾›ç”µè®¾å¤‡ã€‚         |
| **æˆæœ¬**       | **ç³»ç»Ÿæ€»æˆæœ¬å¯èƒ½è¾ƒé«˜**ï¼ˆéœ€é¢å¤–èŠ¯ç‰‡ï¼‰ã€‚                       | **å•èŠ¯ç‰‡æˆæœ¬ä½ï¼Œç³»ç»Ÿæ€»æˆæœ¬é€šå¸¸è¾ƒä½**ï¼ˆå°¤å…¶å¯¹äºç®€å•åº”ç”¨ï¼‰ã€‚   |

---

## 2.**ARM processors (MPUs)**

### a.ARM processor families

#### Cortex-A series (Application)

â€¢ Applications processors 

â€¢ Support OS and high-performance applications e.g. smartphones, Smart TV, smart books

#### Cortex-R series (Real-time)

â€¢ Real-time processors with high performance and high reliability

â€¢ Support real-time processing and mission-critical control e.g. automotive braking system, powertrains

#### Cortex-M series (Microcontroller)

â€¢ Microcontroller

â€¢ Cost-sensitive solutions for deterministic microcontroller applications e.g. smart sensors

### b.ARM Processors vs. ARM Architectures

#### ARM architecture 

â€¢ Describes the details of instruction set, programmerâ€™s model, exception model, and memory map

â€¢ Documented in the Architecture Reference Manual

#### ARM processor

â€¢ Developed using one of the ARM architectures

â€¢ More implementation details, such as timing information

â€¢ Documented in processorâ€™s Technical Reference Manual

| ç‰¹æ€§         | **ARM æ¶æ„ (ARM Architecture)**                              | **ARM å¤„ç†å™¨ (ARM Processor)**                               |
| :----------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **æœ¬è´¨**     | **ä¸€å¥—è®¾è®¡è§„èŒƒ/æ ‡å‡†**                                        | **åŸºäºè¯¥è§„èŒƒ/æ ‡å‡†çš„å…·ä½“ç¡¬ä»¶å®ç°**                            |
| **å®šä¹‰å†…å®¹** | **å®šä¹‰äº†æ ¸å¿ƒè§„åˆ™å’ŒæŠ½è±¡æ¨¡å‹**ï¼š                               | **å®šä¹‰äº†å…·ä½“çš„ç¡¬ä»¶ç»†èŠ‚å’Œå®ç°æ–¹å¼**ï¼š                         |
|              | â€¢ æŒ‡ä»¤é›†æ¶æ„ (ISA)ï¼šæœ‰å“ªäº›æŒ‡ä»¤ã€æŒ‡ä»¤æ ¼å¼ã€åŠŸèƒ½               | â€¢ æµæ°´çº¿çº§æ•°ã€æ·±åº¦                                           |
|              | â€¢ ç¨‹åºå‘˜æ¨¡å‹ï¼šå¯„å­˜å™¨ç»„ç»“æ„ã€å·¥ä½œæ¨¡å¼ï¼ˆå¦‚ç”¨æˆ·æ¨¡å¼ã€ç‰¹æƒæ¨¡å¼ï¼‰ | â€¢ ç¼“å­˜å¤§å°ã€å±‚çº§ç»“æ„ã€æ›¿æ¢ç­–ç•¥                               |
|              | â€¢ å¼‚å¸¸/ä¸­æ–­æ¨¡å‹ï¼šå¼‚å¸¸ç±»å‹ã€å¤„ç†æµç¨‹ã€å‘é‡è¡¨ä½ç½®              | â€¢ å†…å­˜ç®¡ç†å•å…ƒ (MMU) æˆ–å†…å­˜ä¿æŠ¤å•å…ƒ (MPU) çš„å…·ä½“å®ç°         |
|              | â€¢ å†…å­˜æ¨¡å‹ï¼šåœ°å€ç©ºé—´å¸ƒå±€ã€å†…å­˜è®¿é—®å±æ€§ã€å†…å­˜åº               | â€¢ åˆ†æ”¯é¢„æµ‹å™¨è®¾è®¡                                             |
|              | â€¢ è°ƒè¯•æ¶æ„                                                   | â€¢ æ—¶é’Ÿé¢‘ç‡ã€åŠŸè€—ç®¡ç†ç­–ç•¥                                     |
|              | â€¢ å®‰å…¨æ‰©å±• (å¦‚ TrustZone) ç­‰å¯é€‰ç‰¹æ€§                         | â€¢ ç‰©ç†æ¥å£æ—¶åº                                               |
|              |                                                              | â€¢ å¯¹æ¶æ„ä¸­å¯é€‰ç‰¹æ€§çš„å…·ä½“æ”¯æŒï¼ˆå¦‚æ˜¯å¦åŒ…å« NEON, TrustZoneï¼‰   |
| **æ–‡æ¡£**     | **ã€ŠARM æ¶æ„å‚è€ƒæ‰‹å†Œã€‹**                                     | **ã€Šå¤„ç†å™¨æŠ€æœ¯å‚è€ƒæ‰‹å†Œã€‹**                                   |
| **ç›®çš„**     | æä¾›ç»Ÿä¸€çš„ç¼–ç¨‹æ¥å£å’ŒåŸºç¡€è¡Œä¸ºè§„èŒƒï¼Œç¡®ä¿è½¯ä»¶å…¼å®¹æ€§ã€‚           | æŒ‡å¯¼èŠ¯ç‰‡è®¾è®¡è€…å¦‚ä½•å…·ä½“å®ç°è¯¥æ¶æ„ï¼Œå¹¶ä¸ºè½¯ä»¶å¼€å‘è€…å’Œç³»ç»Ÿé›†æˆè€…æä¾›è¯¥èŠ¯ç‰‡çš„ç²¾ç¡®ç¡¬ä»¶ä¿¡æ¯ã€‚ |
| **ç±»æ¯”**     | **å»ºç­‘è®¾è®¡å›¾çº¸**ï¼šè§„å®šäº†æˆ¿å­çš„ç»“æ„ã€æˆ¿é—´å¸ƒå±€ã€æ°´ç”µæ¥å£æ ‡å‡†ç­‰ã€‚ | **å»ºæˆçš„æˆ¿å­**ï¼šæ ¹æ®å›¾çº¸å»ºé€ ï¼Œä½†åŒ…å«äº†å…·ä½“çš„å»ºç­‘ææ–™ã€æ–½å·¥å·¥è‰ºã€å†…éƒ¨ç®¡çº¿æ’å¸ƒç­‰ç»†èŠ‚ã€‚ |

**æ€»ç»“ï¼š**

- **ARM æ¶æ„æ˜¯â€œåšä»€ä¹ˆâ€å’Œâ€œçœ‹èµ·æ¥åº”è¯¥æ€ä¹ˆåšâ€çš„è§„åˆ™è¯´æ˜ä¹¦ã€‚** å®ƒå®šä¹‰äº†è½¯ä»¶ï¼ˆç¼–è¯‘å™¨ã€æ“ä½œç³»ç»Ÿã€åº”ç”¨ç¨‹åºï¼‰å¦‚ä½•ä¸ç¡¬ä»¶äº¤äº’çš„å¥‘çº¦ã€‚
- **ARM å¤„ç†å™¨æ˜¯â€œå…·ä½“æ€ä¹ˆåšå‡ºæ¥â€çš„ç¡¬ä»¶å®ä½“ã€‚** å®ƒæ˜¯åœ¨éµå®ˆæ¶æ„è§„åˆ™çš„å‰æä¸‹ï¼Œç”±å·¥ç¨‹å¸ˆè®¾è®¡å‡ºæ¥çš„å…·ä½“èŠ¯ç‰‡ï¼ŒåŒ…å«äº†æ‰€æœ‰å®ç°æ¶æ„åŠŸèƒ½æ‰€éœ€çš„ç‰©ç†ç”µè·¯å’Œä¼˜åŒ–ç»†èŠ‚ã€‚

### c.Computer Architecture Basic

![image-20250604132632870](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604132632870.png)

---

## 3.**ARM Cortex-M4 Architecture**

![image-20250604133229887](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604133229887.png)

### a.Processor Registers

#### R0 â€“ R12: general purpose registers

---

â€¢ Low registers (R0 â€“ R7) can be accessed by any instruction

â€¢ High registers (R8 â€“ R12) can only be accessed by some instruction

#### R13: Stack Pointer (SP)

---

â€¢ Records the current address of the stack

â€¢ Used for saving the context of a program while switching between tasks

Cortex-M4 has two SPs: 

â€¢ Main SP, used in applications that require privileged access e.g. OS kernel

â€¢ Process SP, used in base-level application code (when not running an exception handler)

#### Program Counter (PC)

---

â€¢ Records the address of the current instruction code

â€¢ Automatically incremented by four at each operation (for 32-bit instruction code), except branching operations

â€¢ A branching operation, such as function calls, will change the PC to a specific address, while saving the current PC to the Link Register (LR)

![image-20250604133831279](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604133831279.png)

#### R14: Link Register (LR)

â€¢ The LR is used to store the return address of a subroutine or a function call

â€¢ The program counter (PC) will load the value from LR after a function is finished

![image-20250604134101568](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604134101568.png)

#### xPSR: combined Program Status Register

Provides information about program execution and ALU flags

> Application PSR (APSR)

> Interrupt PSR (IPSR)

> Execution PSR (EPSR)

### b.Processor Registers vs Peripheral Registers

Processor can directly access processor registers

---

â€¢ For example, ADD r3,r1,r0 ; r3 = r1 + r0

Processor access peripheral registers via *memory mapped I/O*

---

â€¢ Each peripheral register is assigned a fixed memory address at the chip design stage

â€¢ Processor treats peripherals registers the same as data memory

â€¢ Processor uses load/store instructions to read from/write to memory (to be covered in future lectures)

### c.Cortex-M4 processor memory map (Generic)

The Cortex-M4 processor has 4 GB of memory address space

---

â€¢ Support for bit-band operation (detailed later)

The 4GB memory space is architecturally defined with a number of regions

---

â€¢ Each region is designed for particular recommended uses

â€¢ Easy for software programmer to port between different devices

â€¢ The actual usage of the memory map can also be flexibly defined by the user, apart from some fixed memory addresses such as the 

internal private peripheral bus.

![image-20250604135451023](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604135451023.png)

### d.Bit-band operations

Bit-band operations allow a single load/store operation to access a single bit in the memory, for example, in order to set bit[3] in word data in address 0x20000000:

> Bit-bandæ“ä½œå…è®¸å•ä¸ªåŠ è½½/å­˜å‚¨æ“ä½œè®¿é—®å†…å­˜ä¸­çš„å•ä¸ªä½ï¼Œä¾‹å¦‚ï¼Œä¸ºäº†è®¾ç½®åœ°å€0x20000000ä¸­çš„å­—æ•°æ®ä¸­çš„ä½[3]ï¼š

æ­£å¸¸è¯»å†™ï¼š

```assembly
LDR R1, =0x20000000 ; å°†åœ°å€0x20000000åŠ è½½åˆ°R1ï¼ˆå‡è®¾è¿™æ˜¯æˆ‘ä»¬è¦æ“ä½œçš„å¯„å­˜å™¨çš„åœ°å€ï¼‰
LDR R0, [R1]       ; ä»è¯¥åœ°å€è¯»å–32ä½å€¼åˆ°R0ï¼ˆå‡è®¾è¯»å‡ºçš„å€¼æ˜¯0x21ï¼‰
ORR.W R0, #0x8     ; å°†R0çš„bit[3]ç½®1ï¼ˆ0x21 | 0x8 = 0x29ï¼‰
STR R0, [R1]       ; å°†ä¿®æ”¹åçš„å€¼ï¼ˆ0x29ï¼‰å†™å›åŸåœ°å€
```

ä½å¸¦æ“ä½œï¼š

```assembly
LDR R1, =0x2200000C ; å°†ä½å¸¦åˆ«ååœ°å€0x2200000CåŠ è½½åˆ°R1
MOV R0, #1          ; å°†R0è®¾ç½®ä¸º1ï¼ˆè¡¨ç¤ºæˆ‘ä»¬è¦è®¾ç½®å¯¹åº”ä½ä¸º1ï¼‰
STR R0, [R1]        ; å‘è¯¥åœ°å€å†™å…¥1ï¼Œè¿™å°†è®¾ç½®åŸå§‹ä½å¸¦åŒºåŸŸä¸­å¯¹åº”çš„ä½
```


Benefits of bit-band operations


â€¢ Faster bit operations

â€¢ Fewer instructions

â€¢ Atomic operation, avoid hazards

 For example, if an interrupt is triggered and served during the read-modify-write operations, and the interrupt service routine modifies the same data, a data conflict will occur

## 4.**Cortex-M4 Instruction Set**

> ARM Cortex-M4 processor, which is used in the STM32F401 MCU, is designed to work exclusively with Thumb-2 instructions.

```assembly
label mnemonic operand1, operand2, operand3 ; comments
```

### a.Instruction Format: Labels

â€¢ Place marker, marking the memory address of the current instruction

â€¢ Used by branch instructions to implement if-then or goto

â€¢ Must be unique

### b.Instruction Format: Mnemonic

â€¢The name of the instruction

â€¢ Operation to be performed by processor core

### c.Instruction Format: Operands

â€¢ Registers

â€¢ Constants (called *immediate values*)

Normally

â€¢ operand1 is the destination register, and operand2 and operand3 are source operands. 

â€¢ operand2 is usually a register, and the first source operand

â€¢ operand3 may be a register, an immediate number, a register shifted to a constant number of bits, or a \register plus an offset (used for memory access)

### d.Instruction Format: Comments

â€¢ Everything after the semicolon (;) is a comment

â€¢ Explain programmersâ€™ intentions or assumptions

### e.Instruction Format: Suffix

Some instructions can be followed by suffixes to update processor flags or execute the instruction on a certain condition

![image-20250604142307011](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604142307011.png)

## 5.***Understanding ARM Assembly Language***

### a.Memory Access

> Memory access in Cortex-M can be described as â€œLoad, Modify and Storeâ€ model.

![image-20250604142845954](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604142845954.png)

#### Cortex-M4 Endianness

> Cortex-M4æŒ‡ä»¤é›†çš„å­—èŠ‚åº

STM32F401, which is based on the ARM Cortex-M4 core, supports only little-endian memory format.

In little-endian format, the least significant byte (LSB) is stored at the **lowest memory address**, and the most significant byte (MSB) is stored at the **highest memory address**

![image-20250604143134769](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604143134769.png)

#### Load/Store a Byte, Halfword, Word

```assembly
LDRx R0, [R1]; Load data from memory into a 32-bit register
```

>LDRB Load Byte uint8_t unsigned char
>LDRH Load Halfword uint16_t unsigned short int
>LDRSB Load Signed Byte int8_t signed char
>LDRSH Load Signed Halfword int16_t signed short int

```assembly
STRx R0, [R1]; Store data extracted from a 32-bit register into memory
```

> STR**B** Store Lower Byte uint8_t/int8_t unsigned or signed char
> STR**H** Store Lower Halfword uint16_t/int16_t unsigned or signed short

#### Addressing Modes

> å¯»å€æ–¹æ³•

â€¢ Address accessed by LDR/STR is specified by a base register plus an Offset

â€¢ Offset can be an Immediate value 

â€¢ Offset can be hold in a Register

è¿™æ®µè¯æè¿°çš„æ˜¯ **ARM æ±‡ç¼–ä¸­å†…å­˜è®¿é—®æŒ‡ä»¤ï¼ˆ`LDR`/`STR`ï¼‰çš„æ ¸å¿ƒå¯»å€æœºåˆ¶**ã€‚ç®€å•æ¥è¯´ï¼š

> **å†…å­˜åœ°å€ = åŸºå€å¯„å­˜å™¨ + åç§»é‡**
> å…¶ä¸­åç§»é‡å¯ä»¥æ˜¯ â€‹**ç«‹å³æ•°**â€‹ï¼ˆç›´æ¥å†™åœ¨æŒ‡ä»¤ä¸­çš„å¸¸æ•°ï¼‰ï¼Œä¹Ÿå¯ä»¥æ˜¯ â€‹**å¦ä¸€ä¸ªå¯„å­˜å™¨**â€‹ ä¸­å­˜å‚¨çš„å€¼ã€‚

ARM çš„ `LDR`ï¼ˆåŠ è½½ï¼‰å’Œ `STR`ï¼ˆå­˜å‚¨ï¼‰æŒ‡ä»¤è®¿é—®å†…å­˜æ—¶ï¼Œåœ°å€ç”±ä¸¤éƒ¨åˆ†åŠ¨æ€è®¡ç®—ï¼š

- **åŸºå€å¯„å­˜å™¨ï¼ˆBase Registerï¼‰**ï¼šä¸€ä¸ªå¯„å­˜å™¨ï¼ˆå¦‚ `R0`~`R12`ï¼‰å­˜æ”¾åŸºå‡†åœ°å€ã€‚
- **åç§»é‡ï¼ˆOffsetï¼‰**ï¼šä¸€ä¸ªå¯çµæ´»é…ç½®çš„é™„åŠ å€¼ã€‚

 åç§»é‡çš„ä¸¤ç§å½¢å¼ï¼š

| ç±»å‹                    | è¯´æ˜                                              | ç¤ºä¾‹æŒ‡ä»¤                   | å®é™…è®¿é—®åœ°å€       |
| ----------------------- | ------------------------------------------------- | -------------------------- | ------------------ |
| **ç«‹å³æ•°ï¼ˆImmediateï¼‰** | ç›´æ¥å†™åœ¨æŒ‡ä»¤ä¸­çš„å¸¸æ•°ï¼ˆå¦‚ `#4`, `#0x20`ï¼‰ã€‚        | `LDR R0, [R1, #8]`         | `R1çš„å€¼ + 8`       |
| **å¯„å­˜å™¨ï¼ˆRegisterï¼‰**  | åç§»é‡å­˜å‚¨äº**å¦ä¸€ä¸ªå¯„å­˜å™¨**ï¼ˆå¦‚ `R2`ï¼‰ã€‚         | `STR R0, [R1, R2]`         | `R1çš„å€¼ + R2çš„å€¼`  |
|                         | å¯„å­˜å™¨åç§»è¿˜æ”¯æŒ**ç§»ä½æ“ä½œ**ï¼ˆå¦‚å·¦ç§» `LSL #2`ï¼‰ã€‚ | `LDR R0, [R1, R2, LSL #2]` | `R1çš„å€¼ + (R2<<2)` |

------

#### Load/Store Multiple Registers

â€¢ PUSH/POP instructions uses Stack memory, hence no need to specify a Base address.

â€¢ The lower numbered the register is, the lower memory address in the stack.

PUSH instruction uses Stack to store register values temporary until they are retrieved with POP instruction. Stack Pointer (SP) keep track of stack address where the register value is stored.

```assembly
Examples:
PUSH {r1,r2-r4} ; Lowest register in PUSH, will match the 
POP {r5-7, r8} ; lowest register in POP
```

![image-20250604145203467](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604145203467.png)

â€¢ For STM/LDM, the lowest-numbered register is stored/loaded at the lowest memory address.

â€¢ The order in which registers are listed within the bracket {} does not matter.

â€¢ A register (Rn) with a base address is required.

```assembly
Examples:
LDMIA r0!, {r3, r1, r4, r2} ; can also be written as {r1-r4}
STMIA r0!, {r1-r4} ; store in the same order
LDMIA r0!, {r7, r2, r5, r3} 
STMIA r0!, {r1, r5, r2, r3}
```

![image-20250604145216955](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604145216955.png)

### b.Data Movement

```assembly
Examples:
MOVS R11, #0x000B ; Write value of 0x000B to R11, flags get updated
MOV R1, #0xFA05 ; Write value of 0xFA05 to R1, flags are not updated
MOVS R10, R12 ; Write value in R12 to R10, flags get updated
MOV R3, #23 ; Write value of 23 to R3
MOV R8, SP ; Write value of stack pointer to R8
MVNS R2, #0xF ; Write value of 0xFFFFFFF0 (bitwise inverse of 0xF) to the R2 and update flags.
MVN R2, #0xF ; Same as before but no flags update.
MOV R0, PC ; Copy PC (R15) to R0
MOV R1, SP ; Copy SP (R14) to R1
MOV R1, R2, LSL #3 ; R1 = R2 << 3
```

### c.Arithmetic: Addition and Subtraction

```assembly
Examples:
ADD R0, R1, R2 ; R0 = R1 + R2, NZCV flags unchanged
ADDS R0, R1, R2 ; sets NZCV flags on the result
SUBS R8, R6, #240 ; Sets the flags on the result
RSB R4, R4, #1280 ; Subtracts contents of R4 from 1280 
ADCHI R11, RO, R3 ; Only executed if C flag set and Z flag clear.
```

#### Addition resulting C and Z

![image-20250604150151746](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604150151746.png)

#### Addition resulting N and V

![image-20250604150200201](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604150200201.png)

#### 64-bit addition with ADDS and ADC

â€¢ A register can only store 32 bits

â€¢ A 64-bit integer needs two registers

â€¢ Split 64-bit addition into two 32-bit additions

![image-20250604150438086](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604150438086.png)

### d.Arithmetic: Multiply and Divide

```assembly
Short Multiplications:
MUL R10, R2, R5 ; Multiply, R10 = R2 x R5
MLA R10, R2, R1, R5 ; Multiply with accumulate, R10 = (R2 x R1) + R5
MULS R0, R2, R2 ; Multiply with flag update, R0 = R2 x R2 
MULLT R2, R3, R2 ; Conditionally multiply, R2 = R3 x R2
MLS R4, R5, R6, R7 ; Multiply with subtract, R4 = R7 - (R5 x R6)
```

```assembly
Long Multiplications:
UMULL R0, R4, R5, R6 ; Multiplies R5 and R6, writes the top 32 bits to R4
; and the bottom 32 bits to R0
UMAAL R3, R6, R2, R7 ; Multiplies R2 and R7, adds R6, adds R3, writes the
; top 32 bits to R6, and the bottom 32 bits to R3
UMLAL R2, R1, R3, R5 ; Multiplies R5 and R3, adds R1:R2, writes to R1:R2.
```

```assembly
Divisions:
SDIV R0, R2, R4 ; Signed divide, R0 = R2/R4
UDIV R8, R8, R1 ; Unsigned divide, R8 = R8/R1
```

### e.Conditional Instructions

#### Unconditional Branch Instruction

```assembly
MOVS r1, #1
 B target ; Branch to target
 MOVS r2, #2 ; Not executed
 MOVS r3, #3 ; Not executed
 MOVS r4, #4 ; Not executed
target MOVS r5, #5
```

â€¢ A label marks the location of an instruction

â€¢ Labels helps human to read the code

â€¢ In machine program, labels are converted to numeric offsets by assembler

#### Conditional Branch: If-then

```assembly
      ; r1 = a (signed integer), r2 = x
      CMP r1, #0 ; Compare a with 0
      BGE endif ; Go to endif if a â‰¥ 0
then  RSB r1, r1, #0 ; a = - a
endif ADD r2, r2, #1 ; x = x + 1
```

![image-20250604151419356](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604151419356.png)

#### Conditional Branch: If-then-else

![image-20250604151446269](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604151446269.png)

```assembly
     ; r1 = a, r2 = b
     CMP r1, #1 ; compare a and 1
     BNE else ; go to else if a â‰  1 
then MOV r2, #3 ; b = 3 
     B endif ; go to endif
else MOV r2, #4 ; b = 4 
endif
;BLï¼šbranch link ç”¨äºè°ƒç”¨å­ç¨‹åºï¼ŒBLTï¼šless than  ç”¨äºå®ç°æ¡ä»¶è·³è½¬
```

#### Conditional Branch:for

![image-20250604151849039](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604151849039.png)

```assembly
       MOV r0, #0 ; i
       MOV r1, #0 ; sum
loop   CMP r0, #10 ; check whether i < 10
       BGE endloop ; skip if â‰¥
       ADD r1, r1, r0 ; sum += i
       ADD r0, r0, #1 ; i++
       B loop
endloop
```

## 6.**Mixed C and ARM Assembly Language**

![image-20250604152207527](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604152207527.png)

### a.Memory requirements

![image-20250604152432986](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604152432986.png)

C Run-Time Start-Up Module

â€¢ After reset, MCU must:

> Initialize hardware

>> Peripherals, etc.
>
>> Set up stack pointer

> Initialize C or C++ runtime environment

>> Set up heap memory
>
>> Initialize variables

![image-20250604152707345](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604152707345.png)

### b.Functions

â€¢ A function is a subpart of a larger program that is used several times.

> It saves code memory by reusing the functions. (Otherwise the function is copied all over the memory)

â€¢ In C, a function takes arguments from the caller and return a value to the caller.

> The number of arguments varies: from 0 to a large list (consider printf() as an example).

â€¢ Issue 1: What is the mechanism in assembly to call a function and return from a function?

â€¢ Issue 2: How to provide arguments to a function and get a return value?

![image-20250604153443908](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604153443908.png)

![image-20250604153620152](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604153620152.png)

```assembly
__asm int func2(int arg1, int arg2, int arg3, int arg4){
    MULS r0, r1, r0 ; r0 = arg1 * arg2
    MULS r0, r2, r0 ; r0 = r0 * arg3
    MULS r0, r3, r0 ; r0 = r0 * arg4
    BX lr ; return value in r0
}
```

```assembly
__asm int func1(int arg1, int arg2){
MOVS r4, r1 ; r4 = arg2
; 1st argument already in r0
MOVS r1, #4 ; 2nd argument for func2
MOVS r2, #5 ; 3rd argument for func2
MOVS r3, #6 ; 4th argument for func2
BL func2 ; call func2
ADDS r0, r0, r4 ; return value in r0
 â€¦
}
```

However, if we execute the func1 as written, it does not work! Why?

â€¢ r4 is not preserved by func1().

â€¢ LR for func1() is over-written when func2() is called!

---

# week2

## 1.General-Purpose Input/Output (GPIO)

### a.GPIO Configuration

#### GPIO main features

â€¢Each GPIO port has 16 I/Os

â€¢ Each PIN can be configured as Input or Output

â€¢ Output states: push-pull or open drain + pull-up/down

â€¢ Input states: floating, pull-up/down, analog

â€¢ Alternate function (AF) input/output selection registers (at most 16 AFs per I/O)

â€¢ Timer, ADC, UART, SPI, I2C etc.

â€¢ Speed selection for each I/O

â€¢ Fast toggle capable of changing every two clock cycles

â€¢ Highly flexible pin multiplexing allows the use of I/O pins as GPIOs or as one of several peripheral functions

#### STM32F401 Peripheral Memory Map

![image-20250604170315667](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604170315667.png)

![image-20250604170329686](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604170329686.png)

> RCC(Reset and Clock Control)æ˜¯åµŒå…¥å¼ç³»ç»Ÿä¸­ï¼ˆå°¤å…¶æ˜¯åŸºäºARM Cortex-Må†…æ ¸çš„å¾®æ§åˆ¶å™¨ï¼Œå¦‚STM32ç³»åˆ—ï¼‰çš„æ ¸å¿ƒç¡¬ä»¶æ¨¡å—ã€‚ç®€å•æ¥è¯´ï¼Œå®ƒæ˜¯æ•´ä¸ªèŠ¯ç‰‡çš„â€œ**æ—¶é’Ÿå’Œå¤ä½ç®¡ç†å™¨**â€ã€‚

![image-20250604170909562](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604170909562.png)

RCC_AHB1ENR: Enable clock of GPIOA

![image-20250604171019030](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604171019030.png)

![image-20250604171513904](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604171513904.png)

0:IO port A clock disabled

1:IO port A clock enabled

#### GPIO Mode Register (MODER)

![image-20250604172049706](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604172049706.png)

#### GPIO Output Type Register (OTYPE)

![image-20250604172108074](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604172108074.png)

##### Push-Pull

![image-20250604172119459](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604172119459.png)

##### Open-Drain

![image-20250604172129330](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604172129330.png)


 **1. å…³é”®ç‰¹æ€§å¯¹æ¯”**

| **ç‰¹æ€§**         | **æ¨æŒ½ (Push-Pull)**             | **å¼€æ¼ (Open-Drain)**                 |
| ---------------- | -------------------------------- | ------------------------------------- |
| **é©±åŠ¨èƒ½åŠ›**     | å¼ºï¼ˆåŒMOSç®¡é©±åŠ¨é«˜/ä½ç”µå¹³ï¼‰       | å¼±ï¼ˆä»…èƒ½ä¸»åŠ¨æ‹‰ä½ï¼Œé«˜ç”µå¹³é å¤–éƒ¨ä¸Šæ‹‰ï¼‰  |
| **è¾“å‡ºç”µå¹³**     | 0Vï¼ˆä½ï¼‰æˆ– VDDï¼ˆé«˜ï¼‰             | 0Vï¼ˆä½ï¼‰æˆ– **éœ€å¤–éƒ¨ä¸Šæ‹‰è‡³ç›®æ ‡é«˜ç”µå¹³** |
| **å¤–éƒ¨ä¸Šæ‹‰ç”µé˜»** | **ä¸éœ€è¦**                       | **å¿…é¡»**ï¼ˆå¦åˆ™é«˜é˜»æ€æ— æœ‰æ•ˆé«˜ç”µå¹³ï¼‰    |
| **å¼€å…³é€Ÿåº¦**     | å¿«ï¼ˆé«˜ä½ç”µå¹³åˆ‡æ¢è¿…é€Ÿï¼‰           | æ…¢ï¼ˆä»ä½â†’é«˜ä¾èµ–å¤–éƒ¨ç”µé˜»å……ç”µå»¶æ—¶ï¼‰     |
| **åŠŸè€—**         | è¾ƒé«˜ï¼ˆåˆ‡æ¢æ—¶æœ‰ç¬æ€ç”µæµï¼‰         | è¾ƒä½ï¼ˆä»…æ‹‰ä½æ—¶è€—ç”µï¼‰                  |
| **æ€»çº¿å…±äº«èƒ½åŠ›** | ä¸æ”¯æŒï¼ˆè¾“å‡ºå†²çªå¯èƒ½å¯¼è‡´çŸ­è·¯ï¼ï¼‰ | æ”¯æŒï¼ˆå¤šè®¾å¤‡é€šè¿‡â€œçº¿ä¸â€é€»è¾‘å…±äº«æ€»çº¿ï¼‰  |

------

 **2. å…¸å‹åº”ç”¨åœºæ™¯**

| **æ¨¡å¼** | **é€‚ç”¨åœºæ™¯**                                                 | **å…¸å‹æ¡ˆä¾‹**                     |
| -------- | ------------------------------------------------------------ | -------------------------------- |
| **æ¨æŒ½** | â€¢ ç‹¬ç«‹æ•°å­—ä¿¡å·è¾“å‡º â€¢ é«˜é€Ÿå¼€å…³ï¼ˆLEDã€èœ‚é¸£å™¨ç­‰ï¼‰ â€¢ å•å‘æ§åˆ¶ï¼ˆæ— æ€»çº¿å…±äº«ï¼‰ | LEDé©±åŠ¨ã€ç›´æµç”µæœºæ§åˆ¶            |
| **å¼€æ¼** | â€¢ æ€»çº¿é€šä¿¡ï¼ˆé¿å…å¤šè®¾å¤‡å†²çªï¼‰ â€¢ ç”µå¹³è½¬æ¢ï¼ˆè¿æ¥ä¸åŒVDDçš„èŠ¯ç‰‡ï¼‰ â€¢ å…±äº«ä¸­æ–­ä¿¡å·çº¿ | IÂ²Cã€SMBusã€One-Wireæ€»çº¿ã€ä¸­æ–­çº¿ |


>  å½“å¤šä¸ªè®¾å¤‡å…±äº«ä¸€æ¡æ€»çº¿æ—¶ï¼Œåªè¦**ä»»æ„è®¾å¤‡æ‹‰ä½ï¼ˆN-MOSå¯¼é€šï¼‰â€‹**ï¼Œæ•´æ¡çº¿å³ä¸ºä½ç”µå¹³ï¼Œå®ç°å®‰å…¨çš„â€œçº¿ä¸â€ï¼ˆWired-ANDï¼‰é€»è¾‘ï¼Œé¿å…æ¨æŒ½æ¨¡å¼çš„çŸ­è·¯é£é™©ã€‚

 **æ€»ç»“ï¼šå¦‚ä½•é€‰æ‹©æ¨¡å¼ï¼Ÿ**

- é€‰æ¨æŒ½ (Push-Pull)ï¼š
  é©±åŠ¨ç‹¬ç«‹å¤–è®¾ï¼ˆLEDã€ç»§ç”µå™¨ç­‰ï¼‰ï¼Œè¦æ±‚é«˜é€Ÿã€å¼ºé©±åŠ¨èƒ½åŠ›ï¼Œä¸”ä¸ä¸å…¶ä»–è¾“å‡ºå…±äº«çº¿è·¯ã€‚
- é€‰å¼€æ¼ (Open-Drain)ï¼š
  ç”¨äºæ€»çº¿é€šä¿¡ï¼ˆIÂ²Cç­‰ï¼‰ã€å¤šè®¾å¤‡ä¿¡å·å…±äº«ã€ç”µå¹³è½¬æ¢æˆ–éœ€â€œçº¿ä¸â€é€»è¾‘çš„åœºæ™¯ã€‚

#### GPIO â€œOutputâ€ Speed Register (OSPEEDR)

![image-20250604172248688](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604172248688.png)

â€¢ Output Speed: 

> Speed of rising and falling
> Four speeds: Low, Medium, High and Very High

â€¢ Tradeoff

> Higher GPIO speed increases EMI noise and power consumption
>
> Configure based on peripheral speed

> > Low speed for toggling LEDs

> > High speed for SPI

â€¢ Slew Rate(è½¬æ¢é€Ÿç‡)

> Maximum rate of change of the output voltage
>
> A high slew rate allows the output to be toggled at a fast speed.

#### GPIO â€œInputâ€ Pull-up/Pull Down Register (PUPDR)

![image-20250604173107312](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604173107312.png)

![image-20250604173117607](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604173117607.png)

![image-20250604173142716](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604173142716.png)

#### Configure a GPIO pin as Output

![image-20250604173408951](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604173408951.png)

### b.GPIO in C with CMSIS

> CMSIS is a standardised software framework developed by ARM to simplify embedded software development on Cortex-M microcontrollers. It provides a common interface for low-level hardware access, making code portable, efficient, and easy to read.

![image-20250604173731165](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604173731165.png)

#### Key Features of CMSIS

â€¢ CMSIS provides standard predefined headers (e.g. stm32f401xe.h) that define memorymapped registers and peripheral structures.

â€¢ CMSIS transforms memory-mapped registers into C structures (struct), making them more readable and portable.

â€¢ CMSIS provides predefined macros make register manipulation easier to read and less error-prone.

> é¢„å®šä¹‰æ–‡ä»¶

```c
#include "stm32f401xe.h"
int main(void)
{
      // Enable the clock to GPIO Port A
      RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN; 
      // Set PA5 as output (01 = Output)
      GPIOA->MODER &= ~(3UL<<10); 
      GPIOA->MODER |= 1UL<<10;
      // Set PA5 speed to Fast (10)
      GPIOA->OSPEEDR &= ~(3<<10);
      GPIOA->OSPEEDR |= 2<<10; 
      // Set PA5 output to push-pull (0)
      GPIOA->OTYPER &= ~(1<<5); 
      // Set PA5 (bit 5) high
      GPIOA->ODR |= 1<<5;
      // Stay in loop forever to keep LED on
      while(1);
}
```

### c.HAL General Concepts

â€¢ The STM32Cube Hardware abstraction layer (HAL) is the replacement for the standard peripheral library

â€¢ The main objectives of the HAL is to offer

> User friendly APIs that hide the HW complexity and focus on the functionality
>
> Portable APIs that allowing easy migration of user application across different product families

![image-20250604174513423](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604174513423.png)

#### STM32 Startup

![image-20250604174647106](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604174647106.png)

## 2.Interrupts and Events:External Interrupt (EXTI)

### a.How can we detect when a switch is pressed?

Interrupt-driven operations

â€¢ Allows CPU to perform other tasks until external/internal devices require service

â€¢ CPU automatically stops the current code, save its state, jump to the specific code section called interrupt service routine (ISR) and starts to execute it. 

â€¢ Once finished, the processor restores the saved state and resumes the existing tasks in the original code.

![image-20250604185723936](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604185723936.png)

### b.Interrupts types

Hardware interrupts 

---

â€¢ Asynchronous: not related to what code the processor is currently executing

â€¢ Examples: interrupt is asserted e.g. GPIO input is detected, character is received on serial port, or ADC converter finishes 

conversion

System Exceptions, faults, software interrupts 

---

â€¢ Synchronous: are the result of specific instructions executing

â€¢ Examples: undefined instructions, overflow occurs for a given instruction

### c.EXTI: System Configuration Controller (SYSCFG)

![image-20250604191021473](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604191021473.png)

### d.NVIC: Interrupt Vector Table

![image-20250604191309649](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604191309649.png)

PC13 is linked to external interrupt line 13 (EXTI13) that is mapped to NVIC ISR called EXTI15_10_IRQHandler

### e.NVIC: Registers and State

â€¢ Interrupt Enable/Disable

> To enable/disable specific interrupt in NVIC:

> > Enables â†’ NVIC_ISER (Interrupt Set-Enable Register)\
> >
> > Disables â†’ NVIC_ICER (Interrupt Clear-Enable Register)

> CMSIS interface:

> > Enables â†’ NVIC_EnableIRQ(IRQnum)

> > Disables â†’ NVIC_DisableIRQ(IRQnum)

â€¢ Interrupt Priority Group

> Determines the number of bits used to set the number of priority level

> CMSIS interface :

> > Sets priority group â†’ NVIC_SetPriorityGrouping(priority_group)

â€¢ Interrupt Priority

> Determines the priority level of an interrupt (lower value = higher priority).

> Uses register: 

> > NVIC_IPR (Interrupt Priority Register)

> CMSIS interface:

> >Sets priority for an interrupt â†’ NVIC_SetPriority(IRQnum, priority_level)

### f.NVIC: Priority Group

The CMSIS interface â†’ NVIC_SetPriorityGrouping(priority_group) is to how the available priority bits are divided between preemption priority and sub-priority.

â€¢ This setting affect the number of priority levels, and the Priority Byte value that is required to setup the interrupt priority register NVIC_IPR

![image-20250604192425374](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604192425374.png)

Using the default priority_group (4) where 4 bits is used to determine 16 levels of priority level:

![image-20250604192525854](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604192525854.png)

```assembly
Priority_byte = priority_level << (8 â€“ priority_group_bits) & 0xFF
NVICâ†’IP[x] = Priority_byte
```

ä¾‹å¦‚ï¼š

```c
ä»£ç ï¼šNVICâ†’IP[40] = 2 << (8-4) & 0xFF
ä½œç”¨ï¼šè®¾ç½®ä¸­æ–­å·40çš„ä¸­æ–­ä¼˜å…ˆçº§ä¸º2ï¼ˆæ•°å€¼è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜
    
é¦–å…ˆè®¡ç®—ï¼š(8 - 4) = 4   // 8ä¸ºå¯„å­˜å™¨ä½å®½ï¼Œ4ä¸ºå®é™…æœ‰æ•ˆä½å®½ï¼ˆé«˜4ä½ï¼‰
å°†ä¼˜å…ˆçº§å€¼ç§»åˆ°é«˜4ä½ï¼š2 << 4 = 0b0000 0010 << 4 = 0b0010 0000
å±è”½æ— æ•ˆä½ï¼ˆç¡®ä¿ä½4ä½ä¸º0ï¼‰0b00100000 & 0xFF = 0x20
// 0xFF (äºŒè¿›åˆ¶11111111) ç¡®ä¿ç»“æœåœ¨8ä½å†…
// å®é™…ä¸Šæ­¤æ­¥å¯çœç•¥ï¼ˆå› ç§»ä½åå·²è‡ªåŠ¨åœ¨8ä½èŒƒå›´å†…ï¼‰
```

## 3.General-Purpose Timer

![image-20250604193917109](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604193917109.png)

â€¢ Time-base Unit

> 16-bit (TIM3 and TIM4) or 32-bit (TIM2 and TIM5) up, down, up/down counter with its related auto-reload register (ARR).

> 16-bit programmable prescaler (PSC) used to divide (also â€œon the flyâ€) the timer clock input (default APB1 timer clock 84 MHz) by any factor between 1 and 65536.

â€¢ Up to 4 independent channels for:

> Input capture (Our Objective 2)
>
> Output compare
>
> PWM generation (Our Objective 1)
>
> One-pulse mode output

â€¢ Interrupt/DMA generation on the following events:

> Update: counter overflow/underflow, counter initialisation (by software or internal/external trigger)
>
> Trigger event (counter start, stop, initialisation or count by internal/external trigger)
>
> Input capture (Our Objective 2)
>
> Output compare

### a.Base-time unit

![image-20250604194507988](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604194507988.png)

```c
Example 3: 
CK_INT= 84 MHz
PSC = 83
ARR = 999
RCR = 0
Update_event = 84*10^6/((83+1)*(999+1)*(0+1)
= 1000 Hz
```

#### prescaler

> é¢„åˆ†é…å™¨
> â€¢ The prescaler can divide the counter clock frequency by any factor between 1 and 65536. 
> â€¢ It is based on a 16-bit counter controlled through a 16-bit/32-bit register (in the TIMx_PSC register).
> â€¢ It can be â€œchanged on the flyâ€ as this control register is buffered. The new prescaler ratio is taken into account at the next update event.

#### Counter Mode Comparisons

>è®¡æ•°å™¨æ¨¡å¼æ¯”è¾ƒ

![image-20250604194752878](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604194752878.png)

##### Counter Mode â†’ Up

In down-counting mode (edge-aligned), the counter counts from ARR down to 0, then restarts from the auto-reload value and generates a counter underflow event.

![image-20250604194841750](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604194841750.png)

##### Counter Mode â†’ Down

![image-20250604194904570](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604194904570.png)

##### Counter Mode â†’ Center-aligned

In center-aligned mode (up/down counting), the counter counts from 0 to ARR value (up counting), generates a counter overflow event, then counts from ARR down to 1 (down counting) and generates a counter underflow event.

![image-20250604194939439](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604194939439.png)

#### Output Mode

![image-20250604195356247](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604195356247.png)

PWM Mode 1 (Active High)

![image-20250604195426114](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604195426114.png)

PWM Mode 2 (Active Low)

#### Input Capture Mode

â€¢ In Input capture mode, the Capture/Compare Registers (TIMx_CCRx) are used to latch the value of the counter after a transition detected by the corresponding ICx signal.

â€¢ Captures are done in the shadow register, which is copied into the preload register.

##### Input Capture (Rising-edges only)

![image-20250604195728353](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604195728353.png)

## 4.Analogue to Digital Conversion (ADC)

â€¢ Single mode, which converts only one channel, in single-shot or continuous mode.

â€¢ Scan mode, which converts a complete set of pre-defined programmed input channels, in singleshot or continuous mode.

â€¢ Discontinuous mode, converts only a single channel at each trigger signal from the list of predefined programmed input channels.

Default ADC Clock Calculation:

â€¢ If PCLK2 = 84 MHz and the ADC prescaler is set to divide by 4, the ADC clock is:

â€¢ ADCCLK = PCLK2 / 4 = 84 MHz / 4 = 21 MHz 

â€¢ This ensures that the ADC clock is well within the 36 MHz limit.

â€¢ If the clock exceeds the 36 MHz limit, ADC may produce incorrect or noisy results.

â€¢ STM32CubeIDE sets the default ADC prescaler to divide by 4, ensuring that the ADC clock is always within the safe operating range.

### a.ADC Timing Diagram

ADC needs a stabilisation time of tSTAB before it starts converting accurately. After the start of the ADC conversion and after 15 clock cycles, the EOC flag is set and the 16-bit ADC data register contains the result of the conversion. If the EOCIE is set, an interrupt is generated at the end of each conversion.

![image-20250604200753526](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250604200753526.png)

## 5.DMA Concept

Direct Memory Access (DMA)

â€¢ DMA is used in order to provide high-speed data transfer between peripherals and memory and between memory and memory without any CPU action. 

â€¢ This keeps CPU resources free for other operations.

#### DMA Transfer Modes: Peripheral-Memory

â€¢When this mode is enabled (by setting the bit EN in the DMA_SxCR register), each time a peripheral request 

occurs, the stream initiates a transfer from the source to fill the FIFO.

> In FIFO mode, when the threshold level of the FIFO is reached, the contents of the FIFO are drained and stored into the 

destination.

> In Direct mode, the DMA preloads the first data to transfer into an internal FIFO, and transfer to the destination as soon as the peripheral requests a data transfer.

â€¢ The transfer stops once the DMA_SxNDTR register reaches zero, when the peripheral requests the end of transfers (in case of a peripheral flow controller) or when the EN bit in the DMA_SxCR register is cleared by software.

#### DMA Transfer Modes: Memory-Memory

â€¢ In memory-to-memory mode, DMA channels work without being triggered by a request from a peripheral. 

â€¢ When the stream is enabled by setting the Enable bit (EN) in the DMA_SxCR register, the stream immediately starts to fill the FIFO up to the threshold level. When the threshold level is reached, the FIFO contents are drained and stored into the destination.

â€¢ The transfer stops once the DMA_SxNDTR register reaches zero or when the EN bit in the DMA_SxCR register is cleared by software.

#### DMA Request

â€¢ When does the next DMA transfer start?

â€¢ When the peripheral is ready to send or receive data, the peripheral will generate a DMA request signal to the DMA controller to request a data transfer.

---

# week3

## 1.Serial Communications

### a.Serial Data Transmission

#### Synchronous

â€¢ Use shift registers and a clock signal to convert between serial and parallel formats

â€¢ Synchronous: an explicit clock signal is along with the data signal

##### Synchronous: Full-Duplex vs Half-Duplex

Full-duplex communication uses two serial data lines which allows simultaneous send and receive 

![image-20250605130640473](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605130640473.png)

Half-duplex communication: share serial data line which doesnâ€™t allow simultaneous send and receive.

![image-20250605130647827](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605130647827.png)

#### Asynchronous

â€¢ Eliminate the clock line!

â€¢ Transmitter and receiver must generate clock locally

â€¢ Transmitter must add start bit (always same value) to indicate start of each data frame

â€¢ Receiver detects leading edge of start bit, then uses it as a timing reference for sampling data line to extract each data bit N at time Tbit*(N+1.5)

â€¢ Stop bit is also used to detect some timing errors

![image-20250605130525801](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605130525801.png)

## 2.USART (Universal Synchronous Asynchronous Receiver Transmitter)

> é€šç”¨åŒæ­¥å¼‚æ­¥æ”¶å‘å™¨

### a.Overview of USART

â€¢ USART is a hardware communication protocol for data exchange and system control that support both synchronous and asynchronous modes.

![image-20250605132412833](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605132412833.png)

### b.USART Data Packet

â€¢ Typical UART data packet is 8 bits (or 9 bits), no parity bit (N) and 1 stop bit (8N1). 

â€¢ Parity bit can be inserted as an additional bit either Odd or Even (8O1 or 8E1).

â€¢ The TX pin is low during the start bit and high during the stop bit.

â€¢ An Idle character consists of all "1"s for a frame period, followed by a start bit. 

â€¢ A Break character occurs when "0"s are received for a frame period, after which the transmitter inserts stop bit(s).

![image-20250605132724214](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605132724214.png)

#### Configurable stop bits

â€¢1 stop bit: This is the default value of number of stop bits.

â€¢ 2 Stop bits: This will be supported by normal USART, single-wire and modem modes.

â€¢ 0.5 stop bit: To be used when receiving data in Smartcard mode.

â€¢ 1.5 stop bits: To be used when transmitting and receiving data in Smartcard mode.

### c.USART Transmitter: Data transmission Steps

---

â€¢ Enable the USART by writing the UE bit in USART_CR1 register to 1.

â€¢ Program the M bit in USART_CR1 to define the word length (8 or 9 bits).

â€¢ Program the number of stop bits in USART_CR2.

â€¢ Select DMA to enable (DMAT) in USART_CR3 if Multi buffer Communication is to take place. Configure the DMA register as explained in multi-buffer communication.

â€¢ Select the desired baud rate using the USART_BRR register.

â€¢ Set the TE bit in USART_CR1 to send an idle frame as the first transmission.

â€¢ Write the data to send in the USART_DR register (this clears the TXE bit). Repeat this for each data to be transmitted in case of a single buffer.

â€¢ After writing the last data into the USART_DR register, wait until TC=1. This indicates that the transmission of the last frame is complete. This is required for instance when the USART is disabled or enters the Halt mode to avoid corrupting the last transmission.

---

USART Transmitter: TC/TXE behaviour

TXE = Transmission data register (1: data is transferred)

TC = Transmission Complete (1: transmission is complete)

![image-20250605134056109](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605134056109.png)

### d.USART Receiver

#### USART Receiver: Oversampling of bit

â€¢ UART receivers by default use 16x oversampling (or 8x oversampling) for each individual bit to improve bit detection accuracy and to mitigate noise.

![image-20250605134305236](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605134305236.png)

#### USART Receiver: Start bit detection

â€¢ The start bit is detected when a specific sequence of samples is recognised: 

1 1 1 0 X 0 X 0 X 0 0 0 0

â€¢ This sequence is the same for 16x or 8x oversampling

![image-20250605134513585](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605134513585.png)

![image-20250605134525113](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605134525113.png)

#### USART Receiver: Data reception steps

â€¢ Enable the USART by writing the UE bit in the USART_CR1 register to 1.

â€¢ Program the M bit in USART_CR1 to define the word length.

â€¢ Program the number of stop bits in USART_CR2.

â€¢ Select DMA enable (DMAR) in USART_CR3 if multi-buffer communication is to take place. Configure the DMA register as explained in multi-buffer communication. STEP 3

â€¢ Select the desired baud rate using the baud rate register USART_BRR.

â€¢ Set the RE bit USART_CR1. This enables the receiver which begins searching for a start bit

### e.USART Baud Rate

â€¢ Baud rate is the number of bits physically transferred per second

â€¢ Example:

> Baud rate is 115200 bps 
> Each frame: 1 start bit, 8 data bits, 1 stop bit, and no parity bit. 
> Transmission rate of actual data 
>
> > 115200 / 8 = 14400 bps
> > 115200 / (1 + 8 + 1) = 11520 bps
> > Note: start and stop bits are the protocol overhead

---

â€¢ The baud rate for the receiver and transmitter (Rx and Tx) are both set to the same value as programmed in the Mantissa and Fraction values of USARTDIV.

![image-20250605135407059](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605135407059.png)

Where: 

â€¢ f PCLK is the APB1 peripheral block frequency (42 MHz)

â€¢ OVERB=0 oversampling by 8

â€¢ OVERB=1 oversampling by 16

â€¢ USARTDIV is an unsigned fixed-point number that is coded on the USART_BRR register.

> If OVER8 is 0, then the signal is oversampled by 16, and 4 bits are used for the fractional part. 
>
> If OVER8 is 1, then the signal is oversampled by 8, and 3 bits are used.

â€¢ Example:

> If USART_BRR is 0x1BC and OVER8 is 0, then 0x16 is the integer part and 0xD is the fractional part. 
>
> ğ‘ˆğ‘†ğ´ğ‘…ğ‘‡ğ·ğ‘‰= 0x16 + 0xD / 0x10 = 22 + 13/16 = 22.81

 Letâ€™s assume we are configuring USART2:

> APB1 peripheral clock fğ‘ƒğ¶ğ¿ğ¾ = 42 MHz
> Desired baud rate = 115,200 bps
> Oversampled by 16, ğ‘‚ğ‘‰ğ¸ğ‘…8 = 0
>  â€¢ Step 1: We need to determine the value to bewritten into USART_BRR register is: 

 ![image-20250605140317078](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605140317078.png)

 Therefore, the USART_BRR register value is:

> DIV_Mantissa: 22 (0x16)
> DIV_Fraction: 0.786 (0.786 x 16 = 12.576 = 13 â†’ 0xD) 
> Finally, USART_BRR = 0x16D

â€¢ Step 2: We need to validate the Actual baud rate:

![image-20250605140507595](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605140507595.png)

### d.Transmission using DMA

â€¢ DMA mode can be enabled for transmission by setting DMAT bit in the USART_CR3 register. 

â€¢ Data is loaded from a SRAM area configured using the DMA peripheral (refer to the DMA specification) to the USART_DR register whenever the TXE bit is set. 

â€¢ To map a DMA channel for USART transmission, use the following procedure (x denotes the channel number)

### e.Receiver using DMA

â€¢ DMA mode can be enabled for reception by setting the DMAR bit in USART_CR3 register.

â€¢ Data is loaded from the USART_DR register to a SRAM area configured using the DMA peripheral (refer to the DMA specification) whenever a data byte is received. 

â€¢ To map a DMA channel for USART reception, use the following procedure

---

## 3.I2C (Inter-Integrated Circuit)

### a.Bus solution: I2C

â€¢ I2C interface & protocol: make sure messages can be sent from a device to another selected target

![image-20250605141357711](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605141357711.png)

â€¢ Inter-Integrated Circuit (I2C) bus is a two-wire serial interface originally developed by the Philips Semiconductors (now NXP) back in 1982 for use in consumer products.

â€¢ The I2C is a single-master (or multi-master), multi-slaves, synchronous, half-duplex serial communication protocol. 

â€¢ Itâ€™s widely used for attaching lower-speed peripheral ICs to processors and microcontrollers in short-distance, intra-board communication.

![image-20250605141607302](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605141607302.png)

I2C Master (Active role)

>Initializes a transfer
>Generates clock signals
>Send / ask for data
>Terminates a transfer

I2C Slave (Passive role)

>Keep listening to the bus
>Wait to be addressed by the master
>Receive / send data

### b.I2C: Wires

![image-20250605141755406](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605141755406.png)

### c.I2C: Transfer Format

![image-20250605142157301](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605142157301.png)

### e.I2C: Working Modes

â€¢ Master-sender

> Master issues START and ADDRESS, and then transmits data to the addressed slave device

â€¢ Master-receiver

> Master issues START and ADDRESS, and receives data from the addressed slave device

â€¢ Slave-sender

> Master issues START and the ADDRESS of the slave, and then the slave sends data to the master

â€¢ Slave-receiver

> Master issues START and the ADDRESS of the slave, and then the slave receives data from the master.

### f.I2C: Master Write Operation

â€¢ Master sends START condition.

â€¢ Sends address (0x34) + Write bit.

â€¢ Slave responds with ACK.

â€¢ Master sends command byte (register address).

â€¢ Master transmits data byte(s). 

â€¢ Slave response with ACK at 9th clock pulse follows the 8 clock cycles of a byte transfer by Master.

â€¢ STOP condition is sent.

![image-20250605142638270](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605142638270.png)

### G.I2C: Master Read Operation

â€¢ Master sends START condition.

â€¢ Sends address (0x34) + Read bit.

â€¢ Slave responds with ACK.

â€¢ Slave transmits data byte(s).

â€¢ Master sends NACK after the last byte.

â€¢ Master sends STOP condition.

![image-20250605142756507](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605142756507.png)

â€¢ START and STOP must be generated by the master.

â€¢ Data bit is valid only when SCL is '1'.

â€¢ SCL is also generated by the master.

â€¢ The clock frequency determines the data transfer rate.

### H.I2C: Acknowledgement (ACK)

â€¢ ACK (LOW) takes place after every byte is sent when transmitter releases the SDA line so the receiver can pull the SDA line LOW.

â€¢ It signals to the master/transmitter that the byte was successfully received.

â€¢ If SDA remain HIGH, it is a Not acknowledge signal (NACK). Possible scenarios:

â€¢ No receiver on the bus

â€¢ The receiver is unable to receive or transmit (not ready)

â€¢ During the transfer, the receiver does not understand the data / cannot receive any more data bytes.

â€¢ A master-receiver uses NACK to signal the end of the transfer to the slave-transmitter (then generates a STOP).

![image-20250605143049399](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605143049399.png)

---

Recap - Features of I2C

â€¢ All devices attached to the same bus, taking roles of either master or slave.

â€¢ A serial, 8-bit oriented, bi-directional (read/write) data transfer protocol is defined.

â€¢ Each device is assigned a 7-bit unique address.

â€¢ There are only two bus lines - SDA & SCL.

## 4.SPI (Serial Peripheral Interface)

![image-20250605144952721](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605144952721.png)

### a.Fundamental of SPI in STM32F401

â€¢ Four I/O pins are dedicated to SPI communication with external devices.

â€¢ MISO: Master In / Slave Out data. In the general case, this pin is used to transmit data in slave mode and receive data in master mode.

â€¢ MOSI: Master Out / Slave In data. In the general case, this pin is used to transmit data in master mode and receive data in slave mode.

â€¢ SCK: Serial Clock output pin for SPI masters and input pin for SPI slaves.

â€¢ NSS: Slave select pin. Depending on the SPI and NSS settings, this pin can be used to either:

> select an individual slave device for communication
> synchronize the data frame or
> detect a conflict between multiple masters

![image-20250605145442467](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605145442467.png)

â€¢ The SPI can communicate in simplex mode by setting the SPI in transmit-only or in receive-only using the RXONLY bit in the SPIx_CR2 register. 

> Transmit-only mode (RXONLY=0)
>
> Receive-only mode (RXONLY=1)

â€¢ In this configuration, only one line isused for the transfer between the shift registers of the master and slave. 

â€¢ The remaining MISO and MOSI pins pair is not used for communication and can be used as standard GPIOs.

![image-20250605145624988](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605145624988.png)

â€¢ In a configuration with two or more 

independent slaves, the master uses GPIO 

pins to manage the chip select lines for each 

slave.

â€¢ The master must select one of the slaves 

individually by pulling low the GPIO connected 

to the slave NSS input. 

â€¢ When this is done, a standard master and 

dedicated slave communication is established.

### b.Standard multi-slave communication

â€¢ In a configuration with two or more independent slaves, the master uses GPIO pins to manage the chip select lines for each slave.

â€¢ The master must select one of the slaves individually by pulling low the GPIO connected to the slave NSS input. 

â€¢ When this is done, a standard master and dedicated slave communication is established.

![image-20250605145810876](å¾®æ§åˆ¶å™¨å¤ä¹ ç¬”è®°.assets/image-20250605145810876.png)

### c.Data Frame Format

â€¢ The SPI shift register can be set up to shift out MSB-first or LSB-first, depending on the value of the LSBFIRST bit. 

â€¢ Each data frame is 8 or 16 bit long depending on the size of the data programmed using the DFF bit in the SPI_CR1 register. 

â€¢ The selected data frame format is applicable both for transmission and reception.

